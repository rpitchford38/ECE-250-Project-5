/****************************************************
 * Executable:   Weighted_graph_driver
 * Author:  Douglas Wilhelm Harder
 * Copyright (c) 2006-8 by Douglas Wilhelm Harder.  All rights reserved.
 *
 * DO NOT EDIT THIS FILE
 *
 * Create an instance of the WeightedGraphTester class
 * and call the member function run().
 *
 * The member function run() will interpret the
 * input appropriately and exit when the interpreter
 * receives either the command 'exit' or and
 * end-of-file.
 ****************************************************/

#include <iostream>
#include <cmath>
#include <iostream>
#include <stdlib.h>
#include "Weighted_graph.h"

int main() {
	

	std::cout << "Starting Test Run" << std::endl;

	//tester.run();
	//tester.print();
	//Weighted_graph tester(50);
	//// shorter path through other nodes
	//tester.insert(0 ,1, 10.0);
	//tester.insert(0 ,2, 2.0);
	//tester.insert(2 ,1, 2.0);
	//std::cout << "distance between 0 and 1 should be 4.0   " << tester.distance(0, 1) << std::endl;
	//tester.~Weighted_graph();
	

	//// Correctly add the first insertion
	//Weighted_graph tester(10);
	//tester.insert( 0 ,1, 5.0);
	//tester.insert( 0 ,2, 1.0);
	//tester.insert( 0 ,3, 1.0);
	//tester.insert( 0 ,4, 1.0);
	//tester.insert( 0 ,5, 1.0);
	//tester.insert( 0 ,6, 1.0);
	//tester.insert( 0 ,7, 1.0);
	//std::cout << "degree of node 0 should be 7   " << tester.Degree(0) << std::endl;
	//tester.insert( 7 ,5, 1.0);
	//std::cout << "distance between 0 and 1 should be 5.0   " << tester.distance(0, 1) << std::endl;
	//tester.~Weighted_graph();
	//// Add a bunch on one vertex, and still find smallest path to target node
	//Weighted_graph tester(10);
	//tester.insert( 0 ,1, 5.0);
	//tester.insert( 0 ,2, 1.0);
	//tester.insert( 0 ,3, 1.0);
	//tester.insert( 0 ,4, 1.0);
	//tester.insert( 0 ,5, 1.0);
	//tester.insert( 0 ,6, 1.0);
	//tester.insert( 0 ,7, 1.0);
	//tester.insert( 7 ,1, 1.0);
	//std::cout << "distance between 0 and 1 should be 2.0   " << tester.distance(0, 1) << std::endl;
	//tester.~Weighted_graph();
	//// Infinity distance
	//Weighted_graph tester(10);
	//tester.insert( 0 ,1, 5.0);
	//tester.insert( 0 ,2, 1.0);
	//tester.insert( 0 ,3, 1.0);
	//tester.insert( 0 ,4, 1.0);
	//tester.insert( 0 ,5, 1.0);
	//tester.insert( 0 ,6, 1.0);
	//tester.insert( 0 ,7, 1.0);
	//tester.insert( 7 ,1, 1.0);
	//std::cout << "connectivivty: distance between 6 and 9 should be    " << tester.distance(6, 9) << std::endl;
	//tester.~Weighted_graph();
	//// Back track for distance
	//Weighted_graph tester(10);
	//tester.insert( 0 ,1, 5.0);
	//tester.insert( 0 ,2, 1.0);
	//tester.insert( 0 ,3, 1.0);
	//tester.insert( 0 ,4, 1.0);
	//tester.insert( 0 ,5, 1.0);
	//tester.insert( 0 ,6, 1.0);
	//tester.insert( 0 ,7, 1.0);
	//tester.insert( 7 ,1, 1.0);
	//std::cout << "distance between 6 and 7 should be 2.0   " << tester.distance(6, 7) << std::endl;
	//tester.~Weighted_graph();
	//// Sum of distances is important for shortest path, keep longer start bc its shorter
	//Weighted_graph tester(10);
	//tester.insert( 0 ,1, 5.0);
	//tester.insert( 0 ,2, 1.0);
	//tester.insert( 2 ,3, 1.0);
	//tester.insert( 3 ,4, 1.0);
	//tester.insert( 4 ,5, 1.0);
	//tester.insert( 5 ,6, 1.0);
	//tester.insert( 6 ,1, 1.0);
	//std::cout << "distance between 0 and 1 should be 5.0   " << tester.distance(0, 1) << std::endl;
	//tester.~Weighted_graph();
	//// Sum of distances is important for shortest path, take more nodes bc its shorter
	//Weighted_graph tester(10);
	//tester.insert( 0 ,1, 7.0);
	//tester.insert( 0 ,2, 1.0);
	//tester.insert( 2 ,3, 1.0);
	//tester.insert( 3 ,4, 1.0);
	//tester.insert( 4 ,5, 1.0);
	//tester.insert( 5 ,6, 1.0);
	//tester.insert( 6 ,1, 1.0);
	//std::cout << "distance between 0 and 1 should be 6.0   " << tester.distance(0, 1) << std::endl;
	//tester.~Weighted_graph();
	//// breaks if you don't replace properly
	//Weighted_graph tester();
	//tester.insert( 0 ,1, 10.0);
	//tester.insert( 0 ,2, 2.0);
	//tester.insert( 2 ,1, 2.0);
	//std::cout << "distance between 0 and 1 should be 4.0   " << tester.distance(0, 1) << std::endl;
	//tester.insert( 0 ,1, 5.0);
	//tester.insert( 0 ,2, 1.0);
	//tester.insert( 0 ,3, 1.0);
	//tester.~Weighted_graph();
	//// replace the edge
	//Weighted_graph tester();
	//tester.insert( 0 ,1, 5.0);
	//tester.insert( 0 ,1, 1.0);
	//std::cout << "distance between 0 and 1 should be 1.0   " << tester.distance(0, 1) << std::endl;
	//tester.~Weighted_graph();
	// be able to create of a smaller size
	Weighted_graph tester(3);
	std::cout << "distance between 2 and 1 should be 4.0 " << std::endl;
	tester.insert( 0 ,1, 2);
	std::cout << "distance between 2 and 1 should be 4.0 " << std::endl;
	tester.insert( 2 ,1, inf);
	std::cout << "distance between 2 and 1 should be 4.0 " << std::endl;
	tester.insert(3 ,7, 2);
	std::cout << "distance between 2 and 1 should be 4.0 " << std::endl;
	tester.insert(1 ,2, 3);
	std::cout << "distance between 2 and 1 should be 4.0 " << std::endl;
	std::cout << "distance between 2 and 1 should be 4.0   " << tester.distance(2, 1) << std::endl;
	//tester.~Weighted_graph();
	












	/*tester.insert(0, 1, 3.5);
	tester.insert(0, 2, 12.2);
	tester.insert(0, 3, 17.5);
	tester.insert(1, 2, 0.3);

	tester.insert(1, 3, 14.5);
	tester.insert(2, 3, 0.5);

	std::cout << "distance between 3 and 4 is " << tester.distance(3, 4) << std::endl;
	std::cout << "distance between 0 and 3 is " << tester.distance(0, 3) << std::endl;*/
		
	//tester.insert()
	/*tester.insert(1, 2, 3);
	tester.print();
	tester.insert(1, 3, 2);
	tester.insert(1, 5, 1);

	tester.insert(2, 5, 1);
	tester.insert(2, 4, 1);

	tester.insert(3, 4, 5);

	tester.insert(4, 5, 4);*/
	//tester.insert(2, 3, 0.40);
	//tester.insert(1, 2, 0.20);
	//tester.insert(0, 1, 1);
	//tester.insert(0, 2, 2);
	//tester.insert(0, 3, 3);
	//tester.insert(0, 4, 4);

	//tester.insert(1, 2, 1);
	//tester.insert(1, 4, 2);

	//tester.insert(2, 3, 5);

	//tester.insert(3, 4, 2);

	////tester.insert(3, 5, 1);
	////tester.insert(2, 5, 1);
	////tester.insert(4, 5, 1);

	//tester.insert(0, 7, 2);
	//tester.insert(6, 7, 10);
	////tester.insert(6, 5, 15);

	//tester.print();

	//std::cout << "distance between 0 and 1 is " << tester.distance(0, 1) << std::endl;
	//std::cout << "distance between 0 and 2 is " << tester.distance(0, 2) << std::endl;
	//std::cout << "distance between 0 and 3 is " << tester.distance(0, 3) << std::endl;
	//std::cout << "distance between 0 and 4 is " << tester.distance(0, 4) << std::endl;
	//std::cout << "distance between 0 and 5 is " << tester.distance(0, 5) << std::endl;
	//std::cout << std::endl;

	//std::cout << "distance between 1 and 2 is " << tester.distance(1, 2) << std::endl;
	//std::cout << "distance between 1 and 3 is " << tester.distance(1, 3) << std::endl;
	//std::cout << "distance between 1 and 4 is " << tester.distance(1, 4) << std::endl;
	//std::cout << std::endl;

	//std::cout << "distance between 6 and 0 is " << tester.distance(6, 0) << std::endl;
	//std::cout << "distance between 6 and 1 is " << tester.distance(6, 1) << std::endl;
	//std::cout << "distance between 6 and 2 is " << tester.distance(6, 2) << std::endl;
	//std::cout << "distance between 6 and 3 is " << tester.distance(6, 3) << std::endl;
	//std::cout << "distance between 6 and 4 is " << tester.distance(6, 4) << std::endl;
	//std::cout << "distance between 6 and 5 is " << tester.distance(6, 5) << std::endl;
	//std::cout << "distance between 6 and 7 is " << tester.distance(6, 7) << std::endl;
	//std::cout << std::endl;

	//std::cout << "distance between 1 and 4 is " << tester.distance(1, 4) << std::endl;
	//std::cout << "distance between 2 and 5 is " << tester.distance(2, 5) << std::endl;
	//std::cout << "distance between 3 and 5 is " << tester.distance(3, 5) << std::endl;

	//tester.print();
	std::cout << std::endl;
	std::cout << "Finishing Test Run" << std::endl;
	std::cout << std::endl;
	std::cout << std::endl;
	std::cout << std::endl;
	std::cout << std::endl;

	//int const LIMIT = 12;  // This number is subject to change
	//int N = 8;

	//double sum = 0.0;

	//for (int i = 0; i < LIMIT; ++i) {
	//	N *= 2;

	//	Weighted_graph graph(N);

	//	for (int j = 0; j < 8; ++j) {
	//		// Modify some edges
	//		for (int k = 0; k < N*(N - 1) / 20; ++k) {
	//			int m = lrand48() % N;
	//			int n = lrand48() % N;

	//			if (m != n) {
	//				// each distance is between 0.01 and 1.01
	//				double d = drand48();
	//				d = 1.01 - d * d;
	//				graph.insert(m, n, d);
	//			}
	//		}


	//		int m = lrand48() % N;

	//		// Test distances
	//		for (int k = 0; k < 20; ++k) {
	//			int n = lrand48() % N;
	//			std::cout << m << ", " << n << std::endl;
	//			sum += graph.distance(m, n);
	//		}
	//	}
	//}

	//std::cout << sum << std::endl;

	//return 0;

}